#include <cmath>
#include <nlopt.hpp>
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "SpinWave.h"
#include "Initializer.h"
#include "Cell.h"
#include "Cell/Neighbors.h"
#include "Exch_Interaction.h"
#include "AnisotropyInteraction.h"


using namespace std;
using namespace Eigen;

/*typedef struct {
 double a, b;
 } my_constraint_data;
 */

/*double myconstraint(const std::vector<double> &x, std::vector<double> &grad, void *data)
{
     //my_constraint_data *d = reinterpret_cast<my_constraint_data*>(data);
     //double a = d->a, b = d->b;
     //if (!grad.empty()) {
     //grad[0] = 3 * a * (a*x[0] + b) * (a*x[0] + b);
     //grad[1] = -1.0;
     //}
    
    double theta = 129.0*M_PI/180.0;
    double Jab = x[0];
    double Jbb = x[1];
    double Jbbp = x[2];
    double Daz = x[3];
    double Dbz = x[4];
    double Dby = x[5];
    
    double constraint = 24.0*2.5*Jab*cos(theta) -16*Jbb*pow(sin(theta),2) + 16*Jbb*pow(cos(theta),2) -16*Jbbp*pow(sin(theta),2) +16*Jbbp*pow(cos(theta),2) + 8.0*Dbz*pow(sin(theta),2) -8.0*Dbz*pow(cos(theta),2) + 8.0*Dby*pow(cos(theta),2) -8.0*Dby*pow(sin(theta),2) ;
    
    //double constraint = 60.0*Jab + 16.0*Jbb + 16.0*Jbbp -8.0*Dbz + 8.0*Dby;
    
    cout << "constraint = " << constraint << endl;
    return -1.0*constraint;
}*/


/*double myconstraint(const std::vector<double> &x, std::vector<double> &grad, void *data)
{
 
  double Jab = x[1];
  double Jbb = x[2];
  double Jbbp = x[3];
  //double Daz = x[4];
  double Dbz = x[5];
  double Dby = x[6];
     
  double theta = acos((15.0/2.0*Jab)/(2.0*Jbb + 2.0*Jbbp - Dbz + Dby));
  if (isnan(theta))
      return 1.0;
    
  return -1.0*theta;
}*/

double myfunc_4sl(const std::vector<double> &x, std::vector<double> &grad, void *my_func_data)
{
    if (!grad.empty())
    {
        cout << "error: no gradient available" << endl;
    }
    
    double theta = M_PI - acos((15.0/2.0*x[1])/(2.0*x[2] + 2.0*x[3] - x[5] + x[6]));
    cout << "theta= " << theta*180.0/M_PI << " " << 180.0 - theta*180.0/M_PI << endl;
    
    
    Cell cell;
    cell.setBasisVectors(6.0104,6.0104,8.5,90.0,90.0,90.0);
    
    Sublattice Mn0;
    string name = "Mn0";
    Mn0.setName(name);
    Mn0.setType("MN2");
    Mn0.setMoment(2.5,0.0,0.0);
    cell.addSublattice(Mn0);
    cell.addAtom(name,0.0,0.25,0.125);
    cell.addAtom(name,0.5,0.75,0.625);
    
    Sublattice Mn1;
    name = "Mn1";
    Mn1.setName(name);
    Mn1.setType("MN2");
    Mn1.setMoment(2.5,0.0,0.0);
    cell.addSublattice(Mn1);
    cell.addAtom(name,0.5,0.25,0.375);
    cell.addAtom(name,0.0,0.75,0.875);
    
    Sublattice V0;
    name = "V0";
    V0.setName(name);
    V0.setType("V3");
    V0.setMoment(1.0,theta,3.0*M_PI/2.0);
    cell.addSublattice(V0);
    cell.addAtom(name,0.0,0.0,0.5);
    cell.addAtom(name,0.5,0.5,0.0);
    
    Sublattice V1;
    name = "V1";
    V1.setName(name);
    V1.setType("V3");
    V1.setMoment(1.0,theta,0.0);
    cell.addSublattice(V1);
    cell.addAtom(name,0.75,0.25,0.75);
    cell.addAtom(name,0.25,0.75,0.25);
    
    Sublattice V2;
    name = "V2";
    V2.setName(name);
    V2.setType("V3");
    V2.setMoment(1.0,theta,M_PI/2.0);
    cell.addSublattice(V2);
    cell.addAtom(name,0.5,0.0,0.0);
    cell.addAtom(name,0.0,0.5,0.5);
    
    Sublattice V3;
    name = "V3";
    V3.setName(name);
    V3.setType("V3");
    V3.setMoment(1.0,theta,M_PI);
    cell.addSublattice(V3);
    cell.addAtom(name,0.75,0.75,0.25);
    cell.addAtom(name,0.25,0.25,0.75);
    
    SW_Builder builder(cell);
    
    
    cout << "x[i] = ";
    for (size_t i = 0; i<6;i++)
        cout << x[i] << " ";
    cout << endl;

    builder.Add_Interaction(new Exch_Interaction("Jaa",x[0],"Mn0","Mn1",3.0,5.0));
    builder.Add_Interaction(new Exch_Interaction("Jaa",x[0],"Mn1","Mn0",3.0,5.0));
    
    
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn0","V0",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V0","Mn0",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn0","V1",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V1","Mn0",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn0","V2",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V2","Mn0",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn0","V3",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V3","Mn0",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn1","V0",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V0","Mn1",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn1","V1",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V1","Mn1",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn1","V2",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V2","Mn1",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"Mn1","V3",3.48,3.57));
    builder.Add_Interaction(new Exch_Interaction("Jab",x[1],"V3","Mn1",3.48,3.57));
    
    builder.Add_Interaction(new Exch_Interaction("Jbb",x[2],"V0","V2",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbb",x[2],"V2","V0",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbb",x[2],"V1","V3",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbb",x[2],"V3","V1",2.975,3.06));
    
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V0","V1",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V1","V0",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V0","V3",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V3","V0",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V1","V2",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V2","V1",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V2","V3",2.975,3.06));
    builder.Add_Interaction(new Exch_Interaction("Jbbp",x[3],"V3","V2",2.975,3.06));
    
    //string name_in, double value_in, Vector3 unitVectorIn, string sl_r_in
    
    Vector3 xhat(1.0,0.0,0.0);
    Vector3 yhat(0.0,1.0,0.0);
    Vector3 zhat(0.0,0.0,1.0);

    builder.Add_Interaction(new AnisotropyInteraction("Daz",x[4],zhat,"Mn0"));
    builder.Add_Interaction(new AnisotropyInteraction("Daz",x[4],zhat,"Mn1"));
    
    builder.Add_Interaction(new AnisotropyInteraction("Dbz",x[5],zhat,"V1"));
    builder.Add_Interaction(new AnisotropyInteraction("Dbz",x[5],zhat,"V3"));
    builder.Add_Interaction(new AnisotropyInteraction("Dbz",x[5],zhat,"V0"));
    builder.Add_Interaction(new AnisotropyInteraction("Dbz",x[5],zhat,"V2"));
    
    builder.Add_Interaction(new AnisotropyInteraction("Dbx",x[6],xhat,"V1"));
    builder.Add_Interaction(new AnisotropyInteraction("Dbx",x[6],xhat,"V3"));
    builder.Add_Interaction(new AnisotropyInteraction("Dby",x[6],yhat,"V0"));
    builder.Add_Interaction(new AnisotropyInteraction("Dby",x[6],yhat,"V2"));

    SpinWave SW = builder.Create_Element();
    
    
    double KX=0.0, KY = 0.0, KZ = 0.0;
    SW.createMatrix(KX,KY,KZ);
    SW.Calc();
    
    vector<double> frequencies = SW.Get_Frequencies();
    double diff_sq = 0.0;
    std::sort(frequencies.begin(), frequencies.end());
    
    diff_sq += pow((frequencies[0]-2.0)/0.12,2);
    
    
    cout << frequencies[0] << " " << 2.0 << endl;
    //double min_freq = 18.0;
    
    //if(frequencies[2]<min_freq)
    //   diff_sq +=10.0;
    
    KZ = 0.25;
    
    SW.createMatrix(KX,KY,KZ);
    SW.Calc();
    
    frequencies = SW.Get_Frequencies();
    
    std::sort(frequencies.begin(), frequencies.end());
    
    diff_sq += pow((frequencies[0]-5.7)/0.31,2);
    
    //if(frequencies[2]<min_freq)
    //    diff_sq +=10.0;
    
    KZ = 0.5;
    
    SW.createMatrix(KX,KY,KZ);
    SW.Calc();
    
    frequencies = SW.Get_Frequencies();
    
    std::sort(frequencies.begin(), frequencies.end());
    
    diff_sq += pow((frequencies[0]-9.23)/0.85,2);
    diff_sq += pow((frequencies[1]-10.44)/0.35,2);
    
    //if(frequencies[2]<min_freq)
    //    diff_sq +=10.0;
    
    KZ = 0.75;
    
    SW.createMatrix(KX,KY,KZ);
    SW.Calc();
    
    frequencies = SW.Get_Frequencies();
    
    std::sort(frequencies.begin(), frequencies.end());
    
    diff_sq += pow((frequencies[1]-9.92)/0.72,2);
    diff_sq += pow((frequencies[1]-10.38)/0.29,2);

    
    //if(frequencies[2]<min_freq)
    //    diff_sq +=10.0;
    
    
    KZ = 1.0;
    
    SW.createMatrix(KX,KY,KZ);
    SW.Calc();
    
    frequencies = SW.Get_Frequencies();
    
    std::sort(frequencies.begin(), frequencies.end());
    
    diff_sq += pow((frequencies[0]-10.65)/0.48,2);
    diff_sq += pow((frequencies[1]-10.66)/0.46,2);
    
    //if(frequencies[2]<min_freq)
    //    diff_sq +=10.0;
    
    //cout << "Jab = " << Jab << endl;
    cout << "diff_sq = " << diff_sq << endl;;
    
    return diff_sq;
}




int main()
{
    //nlopt::opt opt(nlopt::LD_MMA, 2);
    //std::vector<double> lb(2);
    //lb[0] = -HUGE_VAL; lb[1] = 0;
    //opt.set_lower_bounds(lb);
    
    //my_constraint_data data[2] = { {2,0}, {-1,1} };
    //opt.add_inequality_constraint(myconstraint, &data[0], 1e-8);
    //opt.add_inequality_constraint(myconstraint, &data[1], 1e-8);
    
    nlopt::opt opt(nlopt::LN_COBYLA, 7);
    std::vector<double> ub(7);
    ub[0] =  1.0;
    ub[1] = -1.0;
    ub[2] =-10.2;
    ub[3] = -3.0;
    ub[4] =  1.0;
    ub[5] =  0.7;
    ub[6] = -4.8;
    opt.set_upper_bounds(ub);
    std::vector<double> lb(7);
    lb[0] =  0.0;
    lb[1] = -3.0;
    lb[2] =-10.2;
    lb[3] = -3.0;
    lb[4] = -1.0;
    lb[5] =  0.7;
    lb[6] = -4.8;
    opt.set_lower_bounds(lb);
    opt.set_min_objective(myfunc_4sl, NULL);
    //opt.add_inequality_constraint(myconstraint,NULL, 1e-8);
    opt.set_xtol_rel(1.0e-5);
    std::vector<double> x(7);
    
    x[0] =  0.0;
    x[1] = -1.8;
    x[2] =-10.2;
    x[3] = -3.0;
    x[4] = -0.1 ;
    x[5] =  0.7;
    x[6] = -4.8;
 
    double minf = 0.0;
    
    nlopt::result result = opt.optimize(x, minf);
    
    cout << result << endl;
    
    cout << minf << endl;
    
    cout << "results:" << endl;
    for (vector<double>::iterator it = x.begin(); it!=x.end();it++)
        cout << (*it) << " ";
    cout << endl;
    cout << "chi_squared = " << minf << endl;
    cout << "reduced chi_squared = " << minf/1.0 << endl;
    
    
    /*vector<double> gradient;
    
    for (long i = 0; i!=x.size();i++)
    {
        cout << endl;
        cout << "x[" << i << "] = " << x[i] << endl;
        vector<double> xtemp = x;
        for (int j=-10;j!=11;j++)
        {
            xtemp[i] = x[i] + x[i]*(double)j/10.0;
            cout << xtemp[i] << "  " << (myfunc_4sl(xtemp,gradient,NULL) - minf)/1.0 - 1.0 << endl;
        }
    }*/
    return 0;
}
